/*
Alpaca Broker API

Open brokerage accounts, enable commission-free trading, and manage the ongoing user experience with Alpaca Broker API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ActivityType the model 'ActivityType'
type ActivityType string

// List of ActivityType
const (
	FILL ActivityType = "FILL"
	ACATC ActivityType = "ACATC"
	ACATS ActivityType = "ACATS"
	CSD ActivityType = "CSD"
	CSR ActivityType = "CSR"
	CSW ActivityType = "CSW"
	DIV ActivityType = "DIV"
	DIVCGL ActivityType = "DIVCGL"
	DIVCGS ActivityType = "DIVCGS"
	DIVNRA ActivityType = "DIVNRA"
	DIVROC ActivityType = "DIVROC"
	DIVTXEX ActivityType = "DIVTXEX"
	INT ActivityType = "INT"
	JNLC ActivityType = "JNLC"
	JNLS ActivityType = "JNLS"
	MA ActivityType = "MA"
	NC ActivityType = "NC"
	PTC ActivityType = "PTC"
	REORG ActivityType = "REORG"
	SSO ActivityType = "SSO"
	SSP ActivityType = "SSP"
)

var allowedActivityTypeEnumValues = []ActivityType{
	"FILL",
	"ACATC",
	"ACATS",
	"CSD",
	"CSR",
	"CSW",
	"DIV",
	"DIVCGL",
	"DIVCGS",
	"DIVNRA",
	"DIVROC",
	"DIVTXEX",
	"INT",
	"JNLC",
	"JNLS",
	"MA",
	"NC",
	"PTC",
	"REORG",
	"SSO",
	"SSP",
}

func (v *ActivityType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ActivityType(value)
	for _, existing := range allowedActivityTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ActivityType", value)
}

// NewActivityTypeFromValue returns a pointer to a valid ActivityType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewActivityTypeFromValue(v string) (*ActivityType, error) {
	ev := ActivityType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ActivityType: valid values are %v", v, allowedActivityTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ActivityType) IsValid() bool {
	for _, existing := range allowedActivityTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ActivityType value
func (v ActivityType) Ptr() *ActivityType {
	return &v
}

type NullableActivityType struct {
	value *ActivityType
	isSet bool
}

func (v NullableActivityType) Get() *ActivityType {
	return v.value
}

func (v *NullableActivityType) Set(val *ActivityType) {
	v.value = val
	v.isSet = true
}

func (v NullableActivityType) IsSet() bool {
	return v.isSet
}

func (v *NullableActivityType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableActivityType(val *ActivityType) *NullableActivityType {
	return &NullableActivityType{value: val, isSet: true}
}

func (v NullableActivityType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableActivityType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

